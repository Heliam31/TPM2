<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IOC: TP1 - Prise en main</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IOC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">IOML compiler.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">TP1 - Prise en main </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>L'objectif de ce TP est de mettre un oeuvre un compilateur pour un langage dédié <b>IOML</b> (Input-Output Management Language) dont (a) le front-end est fourni et (b) le back-end reste à écrire. Les phases à implanter sont une partie de l'analyse sémantique, la génération du code, la sélection des instruction, l'allocation des registres et des optimisations.</p>
<p>Pour réaliser le TP, suivez les directives qui vont suivre et essayez de vous conformer au temps indicatif fourni pour chaque partie.</p>
<p><em>Le TP se clôture par la remise des sources que vous aurez produit sur le dépôt correspondant sur Moodle à la date demandée.</em></p>
<p>Pour obtenir l'archive à déposer, tapez la commande : </p><div class="fragment"><div class="line">$ make tp1</div>
</div><!-- fragment --><p>Cela crée un fchier nommé <code>tp1-DATE.tgz</code> avec <em>DATE</em> représentant la date du jour.</p>
<p>Durant cette séance, nous allons :</p><ul>
<li>apprendre le langage <b>IOML</b>,</li>
<li>nous familiariser avec le compilateur <code>ioc</code>,</li>
<li>développer la partie manquante de l'analyse sémantique.</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Le langage IOML (20mn)</h1>
<p><b>IOML</b> possède 2 atouts pour programmer des entrées-sorties matérielles :</p><ul>
<li>sa syntaxe permettant de travailler facilement au niveau binaire,</li>
<li>la structure du code impose l'utilisation d'automate/machine à état.</li>
</ul>
<p>Les instructions peuvent être :</p>
<ul>
<li>des affectations <code>GPIOD_BSRR = 1 &lt;&lt; GREEN_LED</code></li>
<li>des a&#x241B;ectations de bit(s) <code>GPIOD_BSRR[GREEN_LED + 16] = 1</code> <code>GPIOA_OTYPER[2*USER_BUT+1 .. 2*USER_BUT] = GPIO_PUPDR_PD</code></li>
<li>des conditionnelles <code>if TIM3_CNT &gt; 10 then ... else ... endif</code></li>
<li>des changements d'état <code>goto down</code></li>
<li>l'arrêt du programme <code>stop</code></li>
</ul>
<p>Le langage n'accepte qu'un seul type de donné : les entiers 32-bit, et implante les expressions habituelles du C avec des opérateurs supplémentaires :</p><ul>
<li><code>E1 -&gt;&gt; E2</code> : décalage à droite signé,</li>
<li><code>E1 &gt;&gt;&gt; E2</code> : rotation à droite,</li>
<li><code>E1 &lt;&lt;&lt; E2</code> : rotation à gauche,</li>
<li><code>E1 [E2]</code> : accès au bit de numéro <em>E2</em>,</li>
<li><code>E1 [E2 .. E3]</code> : accès à un champ de bit (bit poids fort <em>E2</em> à bit de poids faib le <em>E3</em>).</li>
</ul>
<p>On notera également que, contrairement au C, condition et expressions ne sont pas la mêmechose. Les conditions peuvent être formées de comparaisons (<code>==</code>, <code>!=</code>, ...) et des constructeurs logiques <code>not</code>, <code>and</code> et <code>or</code>.</p>
<p>[VIEW] Pour visualiser un programme complet, vous pouvez ouvrir test <a href="test/pushdown.io">pushdown.io</a>.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Structure du compilateur (20mn)</h1>
<p>[TODO] Vous pouvez désormais charger et décompacter le compilateur <a href="https://moodle.univ-tlse3.fr/mod/resource/view.php?id=341663">io.tgz</a> depuis Moodle.</p>
<p>[TODO] Construisez le compilateur avec <code>make</code>. <code>$ make</code></p>
<p>[TODO] Compilez votre premier fichier : <code>$ ./ ioc -dump -decl test/pushdown.io</code></p>
<p>Les fichiers suivants sont intéressants :</p>
<ul>
<li><code>lexer.ll</code> &ndash; analyseur lexical.</li>
<li><code>parser.yy</code> &ndash; analyseur syntaxique.</li>
<li><code><a class="el" href="main_8cpp.html">main.cpp</a></code> &ndash; programme principal, interface du compilateur.</li>
<li><code><a class="el" href="_a_s_t_8hpp.html">AST.hpp</a></code>, <code><a class="el" href="_a_s_t_8cpp.html">AST.cpp</a></code> &ndash; classes pour les <a class="el" href="class_a_s_t.html">AST</a>.</li>
<li><code><a class="el" href="eval_8cpp.html">eval.cpp</a></code> &ndash; fonctions pour l'évaluation des expressions.</li>
<li><code><a class="el" href="reduce_8cpp.html">reduce.cpp</a></code> &ndash; fonctions pour la réduction des expressions constantes.</li>
</ul>
<p>D'autres fichiers sources seront explorées dans le reste des TPs mais nous allons nous focaliser sur les <a class="el" href="class_a_s_t.html">AST</a>.</p>
<p>La définition des classes pour représenter les <a class="el" href="class_a_s_t.html">AST</a> se trouve dans le fichier <code><a class="el" href="_a_s_t_8hpp.html">AST.hpp</a></code>. La classe de base s'appelle <code><a class="el" href="class_a_s_t.html">AST</a></code>et fournit principalement des services pour localiser l'<a class="el" href="class_a_s_t.html">AST</a> dans le source (variable <code>pos</code>) et une fonction abstraite pour afficher les <a class="el" href="class_a_s_t.html">AST</a> : <code><a class="el" href="class_a_s_t.html#aa3d96e3b261bf0f628281c822d4eb10a">AST::print()</a></code> qui est appelée quand on essaie d'afficher un <a class="el" href="class_a_s_t.html">AST</a> sur <code>cout</code>.</p>
<p>Le class <code><a class="el" href="class_a_s_t.html">AST</a></code> se décline selon 4 classes :</p>
<ul>
<li><code><a class="el" href="class_statement.html">Statement</a></code> &ndash; les instructions,</li>
<li><code><a class="el" href="class_expression.html">Expression</a></code> &ndash; les expressions,</li>
<li><code><a class="el" href="class_condition.html">Condition</a></code> &ndash; les conditions,</li>
<li><code><a class="el" href="class_declaration.html">Declaration</a></code> &ndash; les déclarations (variable, registre, etc).</li>
</ul>
<p>A leur tour, ces classes sont dérivées en sous-classes pour couvrir toutes les formes des <a class="el" href="class_a_s_t.html">AST</a>. Par exemple, <code><a class="el" href="class_statement.html">Statement</a></code>est dérivé en <code><a class="el" href="class_set_statement.html">SetStatement</a></code>, <code><a class="el" href="class_seq_statement.html">SeqStatement</a></code>, <code>If <a class="el" href="class_statement.html">Statement</a></code>, etc. On remarquera que chaque famille d'<a class="el" href="class_a_s_t.html">AST</a> partage un type &ndash; fonction <code>type()</code> permettant de retrouver le vrai type de l'<a class="el" href="class_a_s_t.html">AST</a>.</p>
<p>La classe <code><a class="el" href="class_auto_decl.html">AutoDecl</a></code> permet de représenter un automate, c'est l'<a class="el" href="class_a_s_t.html">AST</a> le plus complexe de tout : il est donc composé d'états (classe <code><a class="el" href="class_state.html">State</a></code>) et chaque état est composé de clauses <em>when</em> (classe <code><a class="el" href="class_when.html">When</a></code>).</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Analyse sémantique : réduction des constantes (temps restant)</h1>
<p>Certaines constructions de IOML nécessitent des constantes mais ces constantes peuvent être calculées à partir d'autres constantes. Il s'agit de la valeur d'une constante, de l'initialisation d'une variable, de l'adresse d'un registre ou de l'indice du bit utilisé dans un signal, comme dans les exemples ci-dessous : </p><pre class="fragment">```
const GPIOA_BASE = 0 x40020000 + 0*0 x400
reg GPIOA_IDR @ GPIOA_BASE + 0 x10
const USER_BUT = 0
const GREEN_LED = 12
sig BUTTON @ GPIOA_IDR[USER_BUT]
```
</pre><p> Donc, au moment de l'analyse, ces constantes sont vues comme des expressions qui doivent ensuite être réduites en constantes de type <code>value_t</code> = <code>uint32_t</code>. Pour ce faire, on utilise les fonctions <code>eval()</code> de classe <code><a class="el" href="class_expression.html">Expression</a></code>. Cette fonction renvoie une valeur optionnelle de type <code>optional&lt;value_t&gt;</code>. Cette valeur s'évalue à vrai si elle est défini (constante), à faux sinon. Dans le premier cas, on peut utiliser <code>*</code> pour récupérer la valeur optionnelle. Au nvieau du C++, cette valeur peut être renvoyée par <code>{}</code> pour indiquer une valeur indéfinie ou la valeur elle-même.</p>
<p>Ainsi, si on a l'addition, <code>A + B</code>, on évalue <em>A</em> et <em>B</em> et si les deux renvoient des valeurs optionnelles définies (constantes), on peut produire une nouvelle constante <em>A</em> + <em>B</em> dont la valeur est renvoyée. Si <em>A</em> ou <em>B</em> sont indéfinies (un des deux n'est pas constant), alors la somme n'est pas une constante et on renvoie la valeur indéfinie <code>{}</code>.</p>
<p>[TODO] L'implémentation de l'évaluation des constantes est définie dans le fichier <code><a class="el" href="eval_8cpp.html">eval.cpp</a></code> où on retrouve la spécialisation de cette fonction pour chacune des classes dérivées d'<code><a class="el" href="class_expression.html">Expression</a></code> :</p>
<ol type="1">
<li>Observez et comprenez <code><a class="el" href="class_const_expr.html#ad5c1459106246d3407e91df5e1065bb1">ConstExpr::eval()</a></code>.</li>
<li>Observez et comprenez <code><a class="el" href="class_mem_expr.html#ac0ffe9b5d8efdea8196f5d320708edb4">MemExpr::eval()</a></code>.</li>
<li>Complétez <code><a class="el" href="class_unop_expr.html#a81050428e1c6b2fc068d125e361c5f29">UnopExpr::eval()</a></code>.</li>
<li>Complétez <code><a class="el" href="class_binop_expr.html#a913f1ef51e6d29acebc5a60c8675eae3">BinopExpr::eval()</a></code>.</li>
<li>Ecrivez <code><a class="el" href="class_bit_field_expr.html#a9623699e5119dabbf5ed8d054134e351">BitFieldExpr::eval()</a></code>.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;ATTENTION : si <a class="el" href="class_bit_field_expr.html">BitFieldExpr</a> avait une forme avec un seul indice, <code>_hi</code> = <code>lo</code>, il serait bien que, après réduction, on garde cette propriété. Cela nous permettra d'améliorer les phases de compilante suivantes. </p>
</blockquote>
<p>Vous pourrez la tester avec le fichier <code>test/pushdown.io</code>. Pour appeler le compilateur sur ces fichiers, on tapera la commande : <code>$ ./ ioc -print-ast test/fichier.io</code></p>
<p>Il est possible d'appliquer cette évaluation de constante aux expressions utilisées dans les <a class="el" href="class_a_s_t.html">AST</a> : ainsi, toute expression constante ne génèrera pas de code et l'exécution sera plus rapide. Pour cela, on ajoute à chaque <a class="el" href="class_a_s_t.html">AST</a> une fonction <code>AST::reduce()</code> qui est appelée pour tenter de réduire au maximum les expressions contenues dans les <a class="el" href="class_a_s_t.html">AST</a>. Elle est définie dans les classes et sous-classes <code><a class="el" href="class_statement.html">Statement</a></code>, <code><a class="el" href="class_condition.html">Condition</a></code> et <code><a class="el" href="class_declaration.html">Declaration</a></code>.</p>
<p>Dans le cas des expression, cette fonction renvoie l'expression réduite en constante (class <code><a class="el" href="class_const_expr.html">ConstExpr</a></code>) si cela est possible ou essaie de réduire en constante une des sous-expressions de l'expression. Ces fonctions sont définies dans le fichier <code><a class="el" href="reduce_8cpp.html">reduce.cpp</a></code>.</p>
<p>[TODO] Complétez les fonctions <code>reduce()</code> suivantes (vous remarquerez qu'on utilise autant-faire-se-peut les fonctions <code>eval</code> définies dans l'exercice précédent):</p>
<ol type="1">
<li>Observez et analysez les fonctions <code>reduce()</code> des classes <code><a class="el" href="class_statement.html">Statement</a></code> et <code><a class="el" href="class_condition.html">Condition</a></code>.</li>
<li><code><a class="el" href="class_binop_expr.html#a9eac5099e13db0ce4682a4541ae5050b">BinopExpr::reduce()</a></code>.</li>
<li><code><a class="el" href="class_bit_field_expr.html#a02bd23042f2774c40a86e81098fe6ed3">BitFieldExpr::reduce()</a></code>.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;ATTENTION : la remarque ci-dessus faite sur <a class="el" href="class_bit_field_expr.html">BitFieldExpr</a> s'applique également. </p>
</blockquote>
<p>Vous pourrez la tester avec les fichiers <code>test/eval.io</code> et <code>test/noconst.io</code>. Pour appeler le compilateur sur ces fichiers, on tapera la commande : <code>$ ./ ioc -print-ast -reduce-const test/fichier.io</code> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
