<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IOC: TP2 : Traduction en quadruplets</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IOC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">IOML compiler.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">TP2 : Traduction en quadruplets </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>Pour réaliser le TP, suivez les directives qui vont suivre et essayez de v indicatif fourni pour chaque partieous conformer au temps.</em></p>
<p>Le TP se clôture par la remise des sources que vous aurez produits sur le dépôt correspondant sur Moodle.</p>
<p>Pour obtenir l'archive à déposer, tapez la commande : <code>$ make tp2</code></p>
<p>Cela crée un fichier nommé <code>tp2-DATE.tgz</code> avec <em>DATE</em> représentant la date du jour.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Prise en main de la traduction (30mn)</h1>
<p>Les quadruplets sont définis dans le fichier <code><a class="el" href="_quad_8hpp.html">Quad.hpp</a></code> où vous trouverez les types suivants :</p>
<ul>
<li><code>lab_t</code> &ndash; type identifiant le numéro des étiquettes dans le code assembleur,</li>
<li><code>reg_t</code> &ndash; type représentant le numéro des registres virtuelles (notez que les 16 premiers numéros sont associés aux registres matériel de l'ARM, R0 à R15).</li>
<li><code><a class="el" href="class_quad.html">Quad</a></code> &ndash; classe représentant un quadruplet.</li>
<li><code><a class="el" href="class_quad_program.html">QuadProgram</a></code> &ndash; classe représentant un programme de quadruplet en cours de génération.</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
Les quadruplets</h2>
<p>Comme il se doit, la classe <a class="el" href="class_quad.html">Quad</a> contient plusieurs champs dont l'interprétation peut dépendre du type de quadruplet : <code>type</code> (type du quadruplet), <code>d</code>, <code>a</code>, <code>b</code>. En général, <code>d</code> représente le numéro du registre destination, <code>a</code> le numéro du registre premier opérande et <code>b</code> le numéro du registre second opérande (s'il y en a un).</p>
<p>La règle ci-dessus s'applique à la plupart des quadruplets réalisant un calcul. Pour les branchements (<code>GOTO</code>), <code>d</code> contient le numero du label sur lequel on branche. Pour l'affectation de constante (<code>SETI</code>), <code>a</code> contient la constante affectée. Pour les accès mémoire, <code>a</code> contient le numéro de registre représentant l'adresse accédée.</p>
<p>Pour vous aider à construire des quadruplets, la class <code><a class="el" href="class_quad.html">Quad</a></code> contient une liste de fonctions statiques permettant de construire des quadruplets d'un type donné et de passer les bons paramètres : <code><a class="el" href="class_quad.html#ad91f7f587fc6f3900f5e8229ef97551e">Quad::add</a></code>, <code><a class="el" href="class_quad.html#a7e6fbd55bcce125f746872d4f25ab0e8">Quad::seti</a></code>, <code>Quad::goto</code>, etc.</p>
<p>On notera le pseudo-quadruplet de type <code>LAB</code> qui permet de définir une étiquette sur lasquelle on pourra brancher.</p>
<blockquote class="doxtable">
<p>&zwj;On notera que les quadrplets peuvent afficher sur la sortie standard <code>cout</code>. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md7"></a>
La représentation du programme</h1>
<p>La classe <code><a class="el" href="class_quad_program.html">QuadProgram</a></code> représente le programme sous forme d'une liste de quadruplets. Pour ajouter un quadruplet à la fin du programme actuel, on utilisera la fonction <code><a class="el" href="class_quad_program.html#afc1eff8eadbcc7a33c7967e6a1795703">QuadProgram::emit()</a></code>.</p>
<p>Elle fournit également quelques services pour aider à la génération du code :</p>
<ul>
<li><code>QuadProgram::new Reg()</code> &ndash; permet d'obtenir un nouveau numéro de registre non-utilisé,</li>
<li><code><a class="el" href="class_quad_program.html#a939d162ac761775d646f930c82f00503">QuadProgram::newLab()</a></code> &ndash; permet d'obtenir un nouveau numéro d'étiquette non-utilisé,</li>
<li><code><a class="el" href="class_quad_program.html#a3e2ea27aabb17ee0e57dc3c567f9de8d">QuadProgram::declare()</a></code> &ndash; alloue un nouveau registre et l'associe avec un identificateur (pratique pour les variables),</li>
<li><code><a class="el" href="class_quad_program.html#a881868530e45e75d08a0bae4559ccaea">QuadProgram::regFor()</a></code> &ndash; permet d'obtenir le numéro de registre associé avec un identificateur (créé avec l'appel précédent).</li>
</ul>
<h2><a class="anchor" id="autotoc_md8"></a>
La traduction d'un automate</h2>
<p>La notion d'automate n'a pas d'équivalent dans le type de machine cible que nous visons, ici, reflétés par les quadruplets. Il va donc falloir la construire de manière synthétique à partir des quadruplets dont nous disposons et de manière à imiter le comportement d'un automate.</p>
<p>Pour cela, il faut bien comprendre le comportement d'un automate :</p>
<ol type="1">
<li>Au démarrage les variables sont initialisées avec leur valeur d'initialisation ou 0.</li>
<li>Au démarrage, le code d'initialisation est exécuté.</li>
<li>Au démarrage, l'automate est dans son premier état tel que trouvé dans les sources.</li>
<li>Quand on rentre dans un état, le code de l'état est exécuté (y compris au démarrage de l'automate).</li>
<li>Un automate ne s'arrête jamais à moins quel'instruction <code>stop</code> ne soit appelée.</li>
<li>Pour changer d'état, l'instruction <code>goto</code> est utilisée.</li>
<li>Dans un état, l'automate teste toutes les clauses <code>when</code> sans arrêt, dans l'ordre où elles apparaissent dans les sources.</li>
<li>Dès qu'une clause <code>when</code> devient vraie, le code de la clause <code>when</code> est exécuté.</li>
</ol>
<p>Il existe plusieurs implantations possibles mais je propose la suivante : </p><pre class="fragment">1   LABEL main
    &lt;initialisation des variables&gt;
    &lt;code d'initialisation de l'automate&gt;
    &lt;POUR chaque état dans l'ordre de sources&gt;
5       LABEL &lt;étiquette état&gt;
        &lt;code d'entrée dans l'état&gt;
        LABEL &lt;test clauses when&gt;
        &lt;POUR chaque clause when&gt;
            &lt;tester la clause&gt;
10          &lt;si la clause est fausse GOTO fin clause&gt;
                &lt;code de la clause&gt;
            LABEL &lt;fin clause&gt;
        GOTO &lt;test clauses when&gt;
    LABEL stop
15  RETURN
</pre><p>Ce modèle est un mélange de quadruplets et de pseudoinstructions entre <code>&lt;</code> ... <code>&gt;</code>. On adoptera les traductions suivantes :</p>
<ul>
<li>16. <code>STOP</code> &ndash; on branchera sur l'étiquette <em>stop</em> (<code>fonction <a class="el" href="class_auto_decl.html#acc5b11f14ca51b4bf65efc0b74eea042">AutoDecl::stopLabel()</a></code>).</li>
<li>17. <code>GOTO</code> <em>s</em> &ndash; on branchera sur l'étiquette <code>&lt;étiquette état&gt;</code> (fonction <code><a class="el" href="class_state.html#a8f36aa5c11164fb9a9ca275252a1dee0">State::label()</a></code>).</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;En bref, un changement d'état sera réalisé par un branchement vers le code implémentant l'état. </p>
</blockquote>
<p>Un état est un morceau de code exécuté dès qu'il est activié et un morceau de code avec une boucle qui teste les clauses <code>when</code>. Une clause <code>when</code> est un test de signal et si le signal est activé, le morceau de code correspondant est exécuté.</p>
<p>Regardons si de manière formelle, notre implantation satisfait la description du comportement de notre automate :</p>
<ul>
<li>(1) est implanté par la ligne 2.</li>
<li>(2) est implanté par la ligne 3.</li>
<li>(3) est supporté par l'ordre de la boucle POUR (ligne 4).</li>
<li>(4) est supporté par la génération de l'étiquette (ligne 5) et du code d'entrée en suivant (ligne 6) et par l'implantation du GOTO (ligne 17).</li>
<li>(5) est supporté par l'implantation du STOP (16) et l'étiquette de stop (lignes 13, 14).</li>
<li>(6) supporté par (17) et le placement des étiquettes d'état (ligne 5-6).</li>
<li>(7) supporté par l'étiquette de boucle (ligne 7), la génération des clauses when (lignes 8-11) et l'instruction de rebouclage (ligne 12).</li>
<li>(8) supporté par le code des clauses (lignes 9-11).</li>
</ul>
<p>Appliqué sur notre exemple pushdown, on doit obtenir un code qui ressemble à ça : </p><pre class="fragment">LABEL main
    &lt; GPIOD_MODER [2* GREEN_LED +1 .. 2* GREEN_LED ] = GPIO_MODER_OUT &gt;
    &lt; GPIOA_MODER [2* USER_BUT +1 .. 2* USER_BUT ] = GPIO_MODER_IN &gt;
    &lt; GPIOA_OTYPER [2* USER_BUT +1 .. 2* USER_BUT ] = GPIO_PUPDR_PD &gt;

LABEL Lup
    &lt; GPIOD_BSRR [ GREEN_LED + 16] = 1&gt;
LABEL Lup-loop
    &lt; tester signal BUTT.ON &gt;
    &lt;si faux GOTO Lup-next0&gt;
        GOTO Ldown
LABEL Lup-next0
    GOTO Lup-loop

LABEL Ldown
    &lt; GPIOD_BSRR [ GREEN_LED ] = 1 &gt;
LABEL Ldown-loop
    &lt; tester signal ! BUTTON &gt;
    &lt;si geux GOTO Ldown-next0 &gt;
        GOTO Lup
LABEL Ldown-next0
    GOTO Lup-loop

LABEL Lstop :
    RETURN
</pre><p> Les textes en <code>&lt;</code> ... <code>&gt;</code> ne sont pas des quadruplets et doivent donner lieu à une traduction.</p>
<p>Notre modèle semble bien correspondre au comportement attendu des automates : on peut démarrer la traduction.</p>
<blockquote class="doxtable">
<p>&zwj;Notez que la traduction des automates, états et clauses <code>when</code> vous sont fournies. Vous aurez juste à implanter la traduction pour les ASTs <code><a class="el" href="class_statement.html">Statement</a></code>, <code><a class="el" href="class_expression.html">Expression</a></code> et <code><a class="el" href="class_condition.html">Condition</a></code>. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md9"></a>
Mise en oeuve</h2>
<p>Le problème majeur, quand on fait un traducteur, est de pouvoir tester les traductions au fur et à mesure ou petit pas par petit pas. L'idée est alors de faire un minimum viable de traductions, de trouver un (des) exemple(s) minimum(s) couvert(s) par la traducteur et de tester sur ce(s) exemple(s).</p>
<p>Ensuite, il suffira de :</p>
<ol type="1">
<li>faire la traduction d'un <a class="el" href="class_a_s_t.html">AST</a>,</li>
<li>écrire un exemple (en IOML) impliquant cet <a class="el" href="class_a_s_t.html">AST</a> (et les <a class="el" href="class_a_s_t.html">AST</a> traduits jusque là)</li>
<li>et de faire le test.</li>
</ol>
<p>On procèdera ainsi jusqu'à avoir fait la traduction complète des <a class="el" href="class_a_s_t.html">AST</a>.</p>
<blockquote class="doxtable">
<p>&zwj;Comme d'habitude, on évitera de tout écrire en une fois et de peiner ensuite à (a) compiler et (b) tester. Il est donc conseillé de compiler très souvent. </p>
</blockquote>
<p>Pour débuter, on utilisera l'exemple minim suivant (dans test <code>zero.io</code>) : </p><pre class="fragment">auto A
    state S :
</pre><p> On obtient alors un magnifique automate <b>A</b> avec un seul état <b>S</b> dans lequel on va rester pour toujours.</p>
<p>Pour le compiler et observer les quadruplets générés, on pourra utiliser la commande : <code>$ ./ ioc -print-quads test/zero.io</code></p>
<p>Et obtiendra : </p><pre class="fragment">L2
L3
    goto L3
L1
    return
</pre><p> Maintenant nous allons pouvoir commencer à réaliser la traduction à proprement parler. Chaque étape qui suit propose une petite extension et un fichier de test pour valider la traduction.</p>
<blockquote class="doxtable">
<p>&zwj;Les fonctions à compléter se trouvent dans le fichier <code><a class="el" href="gen_8cpp.html">gen.cpp</a></code>. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;ATTENTION : pour simplifier les opérations suivants la traduction, on va adopter une approche <b>SSA</b> (<em>Static Single Assignment</em>) allégée. C'est à dire qu'à l'exception des registres qui représentent des variables, un registre ne peut être affecté puis utilisé qu'une seule fois. Cela alloue certes plus de registres mais on verra que cela ne pose pas de problèmes par la suite. Notre implantation <b>SSA* est allégée car elle ne compote pas de d'opération <a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">phi</a>. Les <a class="el" href="class_a_s_t.html">AST</a> mènent assez naturellement vers une forme **SSA</b>. </p>
</blockquote>
<p><b>Affectation à une variable</b> (<code>assign.io</code>) Le pas que nous allons réaliser maintenant est un peu complexe mais va nous permettre ensuite d'implanter toutes les expressions. Nous allons supporter l'affectation dans une variable d'une constante : </p><pre class="fragment">SET (i , CST n )
</pre><p> Donc il va falloir :</p>
<ol type="1">
<li>Implanter la traduction des constantes dans les expressions (fonction <code>ConstExpression::gen()</code>).</li>
<li>Implanter la traduction de l'affectation dans les instructions (fonction <code><a class="el" href="class_set_statement.html#abfd0681ca378529695090bed9f1c4505">SetStatement::gen()</a></code>).</li>
</ol>
<p>Ensuite, on vérifiera si le code produit est bien ce qu'on attend.</p>
<p><b>Traduction de la séquence</b> (<code>seq.io</code>) Cela va nous permettre de traduire des programmes constitués de plusieurs instructions qui se suivent. Traduire la séquence, <em>SEQ (s1 , s2 )</em>, est assez facile à réaliser dans <code><a class="el" href="class_seq_statement.html#a10a16913c7297453348cd0129ae7926f">SeqStatement::gen()</a></code>.</p>
<p><b>Traduction des opérations unaires ou binaires</b> (<code>op.io</code>) Il s'agit ici d'implanter les opérations unaires (<em>NEG</em>, <em>INV</em>) et binaires (<em>ADD</em>, <em>SUB</em>, <em>MUL</em>, <em>DIV</em>, <em>MOD</em>, <em>BIT_AND</em>, <em>BIT_OR</em>, <em>XOR</em>, <em>SHL</em>, <em>SHR</em>, <em>SHA</em>, <em>ROL</em>, <em>ROR</em>). On notera qu'il existe un quadruplet pour chacune de ces opérations (fonctions <code>UnopExpression::gen()</code> et <code>BinopExpressio::gen()</code>).</p>
<p><b>Traduction de l'accès mémoire</b> (<code>mem.io</code>) Maintenant nous allons nous intéresser à l'accès mémoire (classe <code>MemExpression</code>). Seuls les 3 symboles suivants sont supportés dans une expression :</p>
<ul>
<li><code><a class="el" href="class_declaration.html#a216ba9231ebe98269886ffd568a571fbad369ef07d06892d2f9f37f8f56c14a28">Declaration::CST</a></code> &ndash; accès à une constante nommée.</li>
<li><code><a class="el" href="class_declaration.html#a216ba9231ebe98269886ffd568a571fbad467998a9d5010ad06e554b8a724c2db">Declaration::VAR</a></code> &ndash; variable. On se souviendra que les registres associés aux variables sont accessibles avec la fonction <code><a class="el" href="class_quad_program.html#a881868530e45e75d08a0bae4559ccaea">QuadProgram::regFor()</a></code>.</li>
<li><code><a class="el" href="class_declaration.html#a216ba9231ebe98269886ffd568a571fbad467998a9d5010ad06e554b8a724c2db">Declaration::VAR</a></code> &ndash; accès à un registre d'entrée-sortie en mémoire. Il faut réaliser une lecture mémoire (<code><a class="el" href="class_quad.html#ae11fa094a3c0d3a833f942a3a58a3fda">Quad::load</a></code>) à l'adresse du registre.</li>
</ul>
<p><b>Traduction de la sélection</b> (<code>if.io</code>) La sélection <em>if</em> de IOML est très proche de la sélection des autres langages dont le C. Pour simpli&#x241C;er l'implantation, nous allons d'abord seulement considérer le cas où on a affaire avec une condition étant une comparaison simple.</p>
<ol type="1">
<li>Dans la fonction <code><a class="el" href="class_comp_cond.html#a4665936fd64362a9a69c9ce2684531df">CompCond::gen()</a></code>, réalisez la traduction de la comparaison. On appliquera la même approche que pour le langage C.</li>
<li>Dans la fonction <code><a class="el" href="class_if_statement.html#a8d58ec60bde414595f4d0312ec7d5150">IfStatement::gen()</a></code>, réalisez la traduction de <em>if</em> en utilisant bien la traduction de la condition définie précédemment.</li>
</ol>
<p><b>Traduction des autres conditions</b> (<code>short.io</code>) En utilisant, l'évaluation en circuit court vue en cours, réalisez la traduction des autres conditions <code><a class="el" href="class_not_cond.html#a2301cc2e5245d6389fd486788960b8ae">NotCond::gen()</a></code>, <code><a class="el" href="class_and_cond.html#a5607f9a23e40e9e727eeb0e776c45da3">AndCond::gen()</a></code> et <code><a class="el" href="class_or_cond.html#a794d20beb049433f5769d68c302adb86">OrCond::gen()</a></code>.</p>
<p><b>Traduction de champ de bit</b> (<code>bits.io</code>) Cet <a class="el" href="class_a_s_t.html">AST</a> <em>BITFIELD(e, u, l)</em>, permet d'obtenir la valeur des bits <em>l</em> (low) à <em>u</em> (up) bits dans le résultat de l'expression <em>e</em>. Cet opérateur n'existant pas dans nos quadruplets, on pourra la calculer, par exemple, avec l'expression C suivante : _(e &gt;&gt; l) &amp; ((1 &lt;&lt; (u -l + 1)) - 1)_u</p>
<ol type="1">
<li>Dans un premier temps, on pourra appeler le sous-programme <code>L10000</code> (constante <code>field_get_call</code>) qui prend comme paramètre <em>e</em> dans R0, <em>u</em> dans R1 et <em>l</em> dans R2. Le résultat est dans R0.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;NOTE : Ri a pour code de registre (<a class="el" href="class_quad.html#ae7363a96c73684326e07f37ee5cadc9d">Quad::reg_t</a>), i. Les 16 premiers registres virtuels sont réservés pour représenter les registres réels. </p>
</blockquote>
<ol type="1">
<li>On peut distinguer un cas qui va beaucoup simplifier le code : si <em>u</em> = <em>l</em> alors la formule devient _(e &gt;&gt; l) &amp; 1_</li>
</ol>
<p><b>Traduction de l'affectation de champ de bits</b> (<code>setbits.io</code>) Cet <a class="el" href="class_a_s_t.html">AST</a>, <em>SET_BITFIELD(i, u, l, e)</em>, est le pendant de <em>BITFIELD</em> décrit précédemment. Il modifie dans la mémoire <em>i</em> (variable ou registre) les bits <em>u</em> à <em>l</em> avec la valeur produite par l'expression <em>e</em>. Bien sûr, seuls les <em>u − l + 1__ bits de _e</em> sont affectés.</p>
<ol type="1">
<li>Dans un premier temps, on pourra appeler le sous-programme <code>L10001</code> (constante <code>field_set_call</code>) qui prend comme paramètre <em>e</em> dans R0, <em>u</em> dans R1, <em>l</em> dans R2 et <em>e</em> dans R3. Le résultat est dans R0.</li>
<li>On peut distinguer un cas qui va beaucoup simplifier le code : si <em>u</em> = <em>l</em> et que <em>e</em> est une constante alors si <em>e</em> = 1 alors la valeur affectée est <em>i | (1 &lt;&lt; l)</em> si <em>e</em> = 0 alors la valeur affectée est <em>i &amp; ~(1 &lt;&lt; l)</em> Les choses peuvent encore plus simplifiées si <em>l</em> est une constante.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Cela conclura la compilation en quadruplets de IOML. On va pouvoir passer à la sélection des instructions. </p>
</blockquote>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
