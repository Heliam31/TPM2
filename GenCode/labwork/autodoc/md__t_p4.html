<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IOC: TP2 : Traduction en quadruplets</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IOC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">IOML compiler.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">TP2 : Traduction en quadruplets </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Attention</b> La mise en oeuvre de ce TP nécessite le téléchargement d'une archive contenant des fichiers qui vont remplacer certains fichiers du compilateur <code>IOC</code> sans néanmoins toucher les fichiers.</p>
<p>Unptit bug s'est également glissé dans <code><a class="el" href="_inst_8cpp.html">Inst.cpp</a></code> ligne 25 qui doit être (évidemment) : </p><pre class="fragment">```C++
inline Param pwrite(uint32_t x) { return Param::write(x); }
```
</pre><p> <b>Information</b> Le nouveau <code>Makefile</code> peut générer la documentation automatique du compilateur <code>IOC</code> : </p><pre class="fragment">```sh
make autodoc
```
</pre><p> La documentation peut être ouverte avec le fichier <code>autodoc/index.html</code>.</p>
<hr  />
<p> Le TP se clôture par la remise des sources que vous aurez produits sur le dépôt correspondant sur Moodle.</p>
<p>Pour obtenir l'archive à déposer, tapez la commande : <code>$ make tp4</code></p>
<p>Cela crée un fichier nommé <code>tp3-DATE.tgz</code> avec <em>DATE</em> représentant la date du jour.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
La partie à réaliser sont positionnées dans une section &lt;strong&gt;TODO&lt;/strong&gt;.</h1>
<h1><a class="anchor" id="autotoc_md18"></a>
Présentation de l'allocateur de registre</h1>
<p>Dans le cadre du TP, il est difficile de réaliser un allocateur global avec interférence et un allocateur global sans interférence devrait donner un bien piètre résultat étant que la notion de boucle régulière, telles que vues en cours, s'applique difficilement às nos automate. Un allocateur global tel que vu en cours donne également de bien mauvais performances mais il est possible de l'améliorer pour tenir de la forme du code généré : à l'exception des variables de <code>IOML</code>, les registres virtuels sont écrits une seule fois et utilisés une seule fois. Nous allons également une autre amélioration : allouer les registres seulement quand ils sont nécessaire dans le <a class="el" href="class_b_b.html">BB</a>.</p>
<p>Pour ce faire, nous allons avoir besoin des éléments suivants :</p><ul>
<li><em>X</em> ⊂ <em>V</em> &ndash; ensemble des registres virtuels associés avec une variable <code>IOML</code>,</li>
<li><em>m</em>: <em>V</em> ⟶ <em>R</em> ∪ { ⟂ } &ndash; dictionnaire associant à chaque virtuel un registre matérel ou ⟂ (pas d'association),</li>
<li><em>A</em> ⊂ <em>R</em> &ndash; ensemble des registres matériels disponibles,</li>
<li><em>W</em> ⊂ <em>X</em> &ndash; ensemble des registres virtuels qu'il faut sauver en fin de bloc.</li>
</ul>
<p>Pour chaque instruction I(v_i, v_j) avec v_i ensemble des registres écrits, v_j ensemble des registres lus,</p>
<ol type="1">
<li>Allouer les registres lus : pour chaque v_j<ul>
<li>si m[v_j] = ⟂ alors &ndash; allouer un registre matériel<ul>
<li>si A ≠ ∅ alors prendre un registre r de A sinon lever une erreur</li>
<li>m ⟵ m[v_j ⟼ r]</li>
<li>A ⟵ A \ { r }</li>
<li>insérer avant "LDR r, [SP, #k_vj]" &ndash; chargement depuis la pile</li>
</ul>
</li>
<li>remplacer v_j par m[v_j] dans I</li>
</ul>
</li>
<li>Libérer les registres lus <em>morts</em> qui ne sont pas des variables de <code>IOML</code> : pour chaque v_j<ul>
<li>si v_j ∉ X alors &ndash; libérer le registre matériel<ul>
<li>A ⟵ A U { m[v_j] }</li>
<li>m ⟵ m[v_j ⟼ ⟂]</li>
</ul>
</li>
</ul>
</li>
<li>Allouer les registres écrits : pour chaque v_i<ul>
<li>si m[v_i] = ⟂ alors &ndash; allouer un registre matériel<ul>
<li>si A ≠ ∅ alors prendre un registre r de A sinon lever une erreur</li>
<li>m ⟵ m[v_i ⟼ r]</li>
<li>A ⟵ A \ { r }</li>
</ul>
</li>
<li>remplacer v_i par m[v_i] dans I</li>
<li>si v_i ∈ X alors W ⟵ W U { v_i } &ndash; enregistrer v_i pour le sauver en fin de bloc</li>
</ul>
</li>
</ol>
<p>A la fin du <a class="el" href="class_b_b.html">BB</a>, il faut sauvegarde les variables <code>IOML</code> qui ont été mises à jour: pour chaque v_i ∈ W générer "STR, m[v_i], [SP, #k_vi]" <br  />
</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Réalisation de l'allocateur de registre</h1>
<p><b>Important :</b> Il faut tout d'abord noter que l'allocateur utilise qu'un seul type, <code><a class="el" href="class_quad.html#ae7363a96c73684326e07f37ee5cadc9d">Quad::reg_t</a></code>, pour représenter registres virtuels et registres matériels. Simplement les 16 premiers registres virtuels représentent les 16 regitres matériel d'ARM. Cela permet également de ne pas avoir plusieurs classes pour représenter les instructions.</p>
<p>L'allocation des registres est soutenue par 2 classes. La première s'appelle <code><a class="el" href="class_stack_mapper.html">StackMapper</a></code> et prend en charge l'allocation dans la pile de la place pour stocker les variables de <code>IOML</code> : elle permet donc de savoir quel registre virtuel contient une variable <code>IOML</code> et à quel déplacement, relatif au registre <code>SP</code>, est stockée la valeur de la variable <code>IOML</code>. Il n'est pas nécessaire de modifier cette classe qui est utilisée durant l'allocation de tout le <a class="el" href="class_c_f_g.html">CFG</a>.</p>
<p>La seconde classe s'appelle <code><a class="el" href="class_reg_alloc.html">RegAlloc</a></code> et réalise l'allocation des registres pour <b>un</b> <a class="el" href="class_b_b.html">BB</a> : elle est recréée à chaque <a class="el" href="class_b_b.html">BB</a>. Elle met en oeuvre la stratégie d'allocation vue dans la section précédente avec les variables membre suivantes :</p><ul>
<li><code>_map</code> &ndash; implante <em>m</em> (type <a href="https://en.cppreference.com/w/cpp/container/map">map&lt;Quad::reg_t, Quad::reg_t&gt;</a>),</li>
<li><code>_written</code> &ndash; implante <em>W</em> (type <a href="https://en.cppreference.com/w/cpp/container/list">list&lt;Quad::reg_t&gt;</a>),</li>
<li><code>_avail</code> &ndash; implante <em>A</em> (type <a href="https://en.cppreference.com/w/cpp/container/list">list&lt;Quad::reg_t&gt;</a>),</li>
<li><code>_fried_</code> &ndash; non défini dans l'algorithme au dessus mais contient la liste des registres virtuels morts après l'instruction (type <a href="https://en.cppreference.com/w/cpp/container/list">list&lt;Quad::reg_t&gt;</a>).</li>
</ul>
<p>Les fonctions suivantes sont disponibles et seront utiles pour la suite :</p><ul>
<li><code>isVar</code>(<em>r</em>) teste si un registre virtuel correspond à une variable <code>IOML</code>,</li>
<li><code>load</code>(<em>r</em>) génère le code pour charger le registre virtuel donné (après allocation),</li>
<li><code>store</code>(<em>r</em>) génère le cod epour sauvegarder le registre virtuel donné (avant libération).</li>
</ul>
<p>Pour l'instant, l'allocation de registre ne fait rien : il recopie la séquence d'instruction qui lui est passé en paramètre. Il va falloir que vous développiez les fonctions manquantes.</p>
<p><b>TODO</b></p>
<ol type="1">
<li><p class="startli">Développez la fonction <code>allocate</code>(<em>r</em>) qui renvoie le registre matériel associé avec le registre virtuel <em>r</em> qui sera, si nécessaire, alloué. S'il ne reste plus de registre, on pourra lever une erreur avec le code.</p>
<div class="fragment"><div class="line">{C++}</div>
<div class="line">   assert(&quot;no more registers available!&quot; &amp;&amp; false);</div>
</div><!-- fragment --></li>
<li>Développez la fonction <code><a class="el" href="class_reg_alloc.html#ace360e3cf090f234402d90e464cb37a3">RegAlloc::free</a></code>(<em>r</em>) qui libère le registre matériel associé avec le regisre virtuel <em>r</em>.</li>
<li>Développez la fonction <code>RegAlloc::processRead(_p_)</code> qui prend en argument un paramètre d'instruction en lecture et réalise l'allocation de registre en modifiant <em>p</em>.</li>
<li>Développez la fonction <code><a class="el" href="class_reg_alloc.html#aa3fd5525b3bc552fb50e1b6e5f60f9f4">RegAlloc::processWrite</a></code>(<em>p</em>) qui prend en argument un paramètre d'instruction en écriture et réalise l'allocation de registre en modifiant <em>p</em>.</li>
<li>Développez la fonction <code><a class="el" href="class_reg_alloc.html#ac8730f368b8e3035759f55e44e336ca0">RegAlloc::complete</a></code>() qui génère le code pour stocker la valeur des registres <code>IOML</code> modifiés dans le <a class="el" href="class_b_b.html">BB</a>.</li>
<li>Développez la fonction <code><a class="el" href="class_reg_alloc.html#a93597ad33526ca1047b9082dac48590f">RegAlloc::process</a></code>(<em>i</em>) qui prend une instruction en paramètre et réalise l'allocation des registres dans cette instruction. Le code existant, à garder, rajoute l'instruction à la suite des instructions déjà traitées.</li>
</ol>
<p><b>Attention :</b> l'accès aux paramètres d'une instruction <em>i</em> se fait en utilisant la notation tableau <em>i</em>[indice]. Cela renvoie une référence (non constante) sur le paramètre qui peut être passé tel quel à <code><a class="el" href="class_reg_alloc.html#aa05c147b3c6f16ff1192f7c9bb3e0b49">RegAlloc::processRead</a></code>() ou à <code><a class="el" href="class_reg_alloc.html#aa3fd5525b3bc552fb50e1b6e5f60f9f4">RegAlloc::processWrite</a></code>() et être ainsi facilement mis à jour avec l'allocation.</p>
<p><b>Pour tester :</b> 2 options ont été rajoutées à <code>IOC</code></p><ul>
<li><code>-print-alloc</code> &ndash; affiche le <a class="el" href="class_c_f_g.html">CFG</a> après allocation des regstres,</li>
<li><code>-S</code> ou <code>--assembly</code> &ndash; affiche le code assembleur final (donc compilable si tout va bien).</li>
</ul>
<ol type="1">
<li>La gestion du manque de registre matériel (question 1) est très limitée : proposez une stratégie poyur améliorer cela. On pourra être amené à vider des registres dans la pile en utilisant la fonction <code><a class="el" href="class_reg_alloc.html#a98bbabbfce058f9c18063508708fe3a3">RegAlloc::spill</a></code>(). </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
